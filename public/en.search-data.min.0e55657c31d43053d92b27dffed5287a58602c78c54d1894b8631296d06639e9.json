[{"id":0,"href":"/digital-garden-notes/docs/intro/","title":"Load Balancer vs API Gateway -  Understanding the Differences","section":"Docs","content":"In modern application architectures, both Load Balancers and API Gateways play crucial roles in ensuring efficient resource utilization and enhanced performance. However, they serve different purposes and function in unique ways. Here’s a brief overview of each component, along with their differences and use cases.\nWhat is a Load Balancer? # A Load Balancer is a device or software that distributes incoming network traffic across multiple servers. The primary goal is to ensure no single server becomes overwhelmed, which can lead to degraded performance or downtime. Load Balancers improve application availability and reliability by:\nDistributing traffic: Balancing the load among several servers, leading to improved resource utilization. Fault tolerance: Automatically rerouting traffic from failed servers to healthy ones. Scalability: Easily adding or removing servers based on demand. What is an API Gateway? # An API Gateway is a server that acts as an intermediary between clients and backend services. It manages API requests, handles traffic, and provides additional functionality such as authentication, logging, rate limiting, and response transformation. Key features of an API Gateway include:\nCentralized access point: Serving as the entry point for all API requests, streamlining communication between clients and services. Traffic management: Handling and directing requests to appropriate services based on routing rules. Security: Implementing authentication and authorization mechanisms to protect backend services. Key Differences # Feature Load Balancer API Gateway Primary Function Distributes traffic among multiple servers Manages API requests and responses Use Case Enhancing availability and performance Centralized access and management of APIs Protocol Support Primarily operates at the transport layer (TCP/UDP) Operates at the application layer (HTTP/HTTPS) Features Load distribution, health checks, SSL termination Authentication, rate limiting, logging, caching Use Cases # Load Balancer: Ideal for web applications, microservices, or any architecture where traffic distribution is essential for performance and availability. API Gateway: Best suited for scenarios where APIs are exposed to clients, providing a single point of entry for managing requests, securing services, and optimizing communication. Diagram: Load Balancer vs. API Gateway # Below is a diagram illustrating the relationship between clients, Load Balancers, API Gateways, and backend services:\nConclusion # Understanding the differences between Load Balancers and API Gateways is crucial for designing scalable and efficient applications. While Load Balancers focus on distributing network traffic and enhancing performance, API Gateways manage API interactions, providing additional features like security and traffic management. Together, they form an essential part of modern cloud-native architectures, ensuring smooth operation and a seamless user experience.\n"},{"id":1,"href":"/digital-garden-notes/docs/load-balancer-vs-api-gateway----understanding-the-differences/","title":"Load Balancer vs API Gateway -  Understanding the Differences","section":"Docs","content":"In modern application architectures, both Load Balancers and API Gateways play crucial roles in ensuring efficient resource utilization and enhanced performance. However, they serve different purposes and function in unique ways. Here’s a brief overview of each component, along with their differences and use cases.\nWhat is a Load Balancer? # A Load Balancer is a device or software that distributes incoming network traffic across multiple servers. The primary goal is to ensure no single server becomes overwhelmed, which can lead to degraded performance or downtime. Load Balancers improve application availability and reliability by:\nDistributing traffic: Balancing the load among several servers, leading to improved resource utilization. Fault tolerance: Automatically rerouting traffic from failed servers to healthy ones. Scalability: Easily adding or removing servers based on demand. What is an API Gateway? # An API Gateway is a server that acts as an intermediary between clients and backend services. It manages API requests, handles traffic, and provides additional functionality such as authentication, logging, rate limiting, and response transformation. Key features of an API Gateway include:\nCentralized access point: Serving as the entry point for all API requests, streamlining communication between clients and services. Traffic management: Handling and directing requests to appropriate services based on routing rules. Security: Implementing authentication and authorization mechanisms to protect backend services. Key Differences # Feature Load Balancer API Gateway Primary Function Distributes traffic among multiple servers Manages API requests and responses Use Case Enhancing availability and performance Centralized access and management of APIs Protocol Support Primarily operates at the transport layer (TCP/UDP) Operates at the application layer (HTTP/HTTPS) Features Load distribution, health checks, SSL termination Authentication, rate limiting, logging, caching Use Cases # Load Balancer: Ideal for web applications, microservices, or any architecture where traffic distribution is essential for performance and availability. API Gateway: Best suited for scenarios where APIs are exposed to clients, providing a single point of entry for managing requests, securing services, and optimizing communication. Diagram: Load Balancer vs. API Gateway # Below is a diagram illustrating the relationship between clients, Load Balancers, API Gateways, and backend services:\nConclusion # Understanding the differences between Load Balancers and API Gateways is crucial for designing scalable and efficient applications. While Load Balancers focus on distributing network traffic and enhancing performance, API Gateways manage API interactions, providing additional features like security and traffic management. Together, they form an essential part of modern cloud-native architectures, ensuring smooth operation and a seamless user experience.\n"},{"id":2,"href":"/digital-garden-notes/docs/personal-knowledge-management-with-hugo--obsidian/","title":"Personal Knowledge Management with Hugo \u0026 Obsidian","section":"Docs","content":" Prerequisites # Obsidian installed on your machine Basic knowledge of Markdown A GitHub account Hugo installed on your machine (if not, follow the official installation guide) Git installed on your machine Step 1: Set up GitHub repository # Create a new repository on GitHub.\nGo to your GitHub account and create a new repository. Name it \u0026lt;your-username\u0026gt;.github.io (replace \u0026lt;your-username\u0026gt; with your GitHub username). This is important because GitHub Pages uses this naming convention to host user pages. Set it as public and initialize it with a README.md file. Clone the repository to your local machine.\nbash\nCopy code\ngit clone https://github.com/\u0026lt;your-username\u0026gt;/\u0026lt;your-username\u0026gt;.github.io cd \u0026lt;your-username\u0026gt;.github.io\nStep 2: Install and configure Hugo # Install Hugo if not already installed.\nYou can install Hugo from the terminal. Follow the instructions based on your OS from the Hugo website. Create a new Hugo site. Inside your cloned repository:\nbash\nCopy code\nhugo new site my-digital-garden cd my-digital-garden\nChoose a theme.\nHugo has a wide selection of themes, but since we are creating a digital garden, you can use a theme like hugo-book or hugo-theme-digitalgarden.\nDownload a theme and add it to your Hugo site:\nbash\nCopy code\ngit submodule add https://github.com/apvarun/digital-garden-hugo.git themes/digital-garden-hugo\nUpdate Hugo\u0026rsquo;s configuration (config.toml).\nUpdate your config.toml to use the theme and configure the basic site settings.\nExample:\ntoml\nCopy code\nbaseURL = \u0026quot;https://\u0026lt;your-username\u0026gt;.github.io/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My Digital Garden\u0026quot; theme = \u0026quot;digital-garden-hugo\u0026quot;\nStep 3: Integrating Obsidian with Hugo # Create an Obsidian vault if you haven’t already, or use your existing vault.\nOpen Obsidian and go to your vault. Set the Hugo content directory as a folder in Obsidian.\nInside your Hugo project, go to the content directory. Link this directory with Obsidian by adding it as a folder inside your Obsidian vault. Write notes in Obsidian using Markdown.\nEach note will become a page in your Hugo-generated site.\nFor each note you want to publish, ensure it’s saved as a .md file in the content folder.\nExample front matter for each note (for Hugo):\nyaml\nCopy code\n--- title: \u0026quot;My Note Title\u0026quot; date: 2024-10-20 ---\nUse Obsidian’s bidirectional linking.\nYou can use Obsidian’s link syntax ([[Note Title]]) to link notes, which will work well when you generate the site in Hugo. Step 4: Build and test the Hugo site locally # Build your site locally. Inside your Hugo directory, run:\nbash\nCopy code\nhugo server\nThis will start a local server on localhost:1313, allowing you to preview your digital garden. Make adjustments to the content and theme.\nAs you view the site, make changes to your config.toml, themes, or add custom CSS if necessary to match your desired look. Step 5: Deploy to GitHub Pages # Build the static files for GitHub Pages:\nbash\nCopy code\nhugo\nThis will generate your site in the public/ directory. Push the site to GitHub.\nMove all files from the public directory to the root of your GitHub Pages repository.\nCommit the changes:\nbash\nCopy code\ngit add . git commit -m \u0026quot;Deploy Hugo site\u0026quot; git push origin main\nSet up GitHub Pages.\nIn your GitHub repository, go to Settings \u0026gt; Pages. Select the main branch as the source and save. Visit your site.\nAfter GitHub Pages builds your site, visit \u0026lt;your-username\u0026gt;.github.io. Step 6: Automating with GitHub Actions (optional) # You can automate the process of building and deploying your Hugo site using GitHub Actions.\nCreate a .github/workflows/gh-pages.yml file in your repository:\nyaml\nCopy code\nname: Deploy Hugo site on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Set up Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' - name: Build the site run: hugo - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public\nCommit and push the workflow file:\nbash\nCopy code\ngit add .github/workflows/gh-pages.yml git commit -m \u0026quot;Add GitHub Actions workflow\u0026quot; git push origin main\nNow, every time you push new content to the main branch, GitHub Actions will automatically build and deploy your Hugo site.\nStep 7: Keep Adding and Updating Content # Now you can use Obsidian to manage your notes and content. Any notes you write in Obsidian will be reflected in your digital garden on GitHub Pages whenever you commit and push them.\n"},{"id":3,"href":"/digital-garden-notes/docs/setup-github/","title":"Setup Github","section":"Docs","content":" Check if you have an SSH key # Run the following command to see if you already have an SSH key:\nbash\nCopy code\nls -al ~/.ssh\nYou should see something like id_rsa and id_rsa.pub. If these files are not present, you’ll need to generate a new SSH key.\n2. Generate a new SSH key (if you don\u0026rsquo;t have one) # If you don\u0026rsquo;t have an SSH key, you can create one by running:\nbash\nCopy code\nssh-keygen -t rsa -b 4096 -C \u0026quot;your_email@example.com\u0026quot;\nFollow the prompts, and it will generate a key pair (id_rsa and id_rsa.pub) in the ~/.ssh directory.\n3. Add your SSH key to the ssh-agent # Run the following commands to start the ssh-agent and add your key:\nbash\nCopy code\neval \u0026quot;$(ssh-agent -s)\u0026quot; ssh-add ~/.ssh/id_rsa\n4. Add your SSH key to GitHub # Now, you need to add the public key to your GitHub account:\nCopy the SSH key to your clipboard:\nbash\nCopy code\ncat ~/.ssh/id_rsa.pub\nGo to GitHub:\nNavigate to Settings \u0026gt; SSH and GPG keys. Click New SSH Key and paste your public key there. 5. Test your SSH connection to GitHub # To confirm that GitHub is now recognizing your SSH key, run:\nbash\nCopy code\nssh -T git@github.com\nIf successful, you\u0026rsquo;ll see a message like:\nvbnet\nCopy code\nHi your_username! You've successfully authenticated, but GitHub does not provide shell access.\n6. Try pushing again # Now, you can try pushing your changes again:\nbash\nCopy code\ngit push origin main\nThis should work without the permission error. Let me know if you encounter any other issues!\n"}]